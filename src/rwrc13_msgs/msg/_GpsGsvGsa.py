"""autogenerated by genpy from rwrc13_msgs/GpsGsvGsa.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import std_msgs.msg

class GpsGsvGsa(genpy.Message):
  _md5sum = "24c5e8414432dbbfe7f80e780223e5dd"
  _type = "rwrc13_msgs/GpsGsvGsa"
  _has_header = True #flag to mark the presence of a Header object
  _full_text = """Header header

#GGA
float64 lat	
float64 lon	
int32 precision	
int32 satelites	#The number of Satelites
float32 hdop	#Horizontal dilution of position	
float64 alt 	#Altitude(Meters) above mean sea level	
float64 geo	#Height of geoid (mean sea level) above WGS84 	
int32 lack	#Time in seconds since last DGPS update	
	
#GST
float32 rms	#Total RMS standard deviation of ranges inputs to the navigation solution
float32 smd1	#Standard deviation1 (meters) of semi-major axis of error ellipse
float32 smd2	#Standard deviation2 (meters) of semi-major axis of error ellipse
float32 smo	#Orientation Orientation of semi-major axis of error ellipse (true north degrees)
float32 laed	#Standard deviation (meters) of latitude error
float32 loed	#Standard deviation (meters) of longitude error
float32 aled	#Standard deviation (meters) of Altitude error

#GSA
int32[] id		#Satellites used in the position solution, a null field occurs if a channel is unused
float32 pdop	#Position Dilution of Precision (PDOP)
float32 vdop	#Vertical Dilution of Precision (VDOP)


#VTG
float32 gs	#Ground speed

#GSV
int32 tn					#Total number of satellites in view
int32 mn				#message_number
int32[] sn				#Satellite number
int32[] elevation	#Elevation in degrees, =0to90
int32[] azimuth		#Azimuth (true) in degrees, =0to359
int32[] snr				#SNR(dB) +30, =99

#kiuchi special
int32[4] sa1
int32[4] sa2
int32[4] sa3
int32[4] sa4
int32[4] sa5
int32[4] sa6
int32[4] sa7
int32[4] sa8




================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id

"""
  __slots__ = ['header','lat','lon','precision','satelites','hdop','alt','geo','lack','rms','smd1','smd2','smo','laed','loed','aled','id','pdop','vdop','gs','tn','mn','sn','elevation','azimuth','snr','sa1','sa2','sa3','sa4','sa5','sa6','sa7','sa8']
  _slot_types = ['std_msgs/Header','float64','float64','int32','int32','float32','float64','float64','int32','float32','float32','float32','float32','float32','float32','float32','int32[]','float32','float32','float32','int32','int32','int32[]','int32[]','int32[]','int32[]','int32[4]','int32[4]','int32[4]','int32[4]','int32[4]','int32[4]','int32[4]','int32[4]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,lat,lon,precision,satelites,hdop,alt,geo,lack,rms,smd1,smd2,smo,laed,loed,aled,id,pdop,vdop,gs,tn,mn,sn,elevation,azimuth,snr,sa1,sa2,sa3,sa4,sa5,sa6,sa7,sa8

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(GpsGsvGsa, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.lat is None:
        self.lat = 0.
      if self.lon is None:
        self.lon = 0.
      if self.precision is None:
        self.precision = 0
      if self.satelites is None:
        self.satelites = 0
      if self.hdop is None:
        self.hdop = 0.
      if self.alt is None:
        self.alt = 0.
      if self.geo is None:
        self.geo = 0.
      if self.lack is None:
        self.lack = 0
      if self.rms is None:
        self.rms = 0.
      if self.smd1 is None:
        self.smd1 = 0.
      if self.smd2 is None:
        self.smd2 = 0.
      if self.smo is None:
        self.smo = 0.
      if self.laed is None:
        self.laed = 0.
      if self.loed is None:
        self.loed = 0.
      if self.aled is None:
        self.aled = 0.
      if self.id is None:
        self.id = []
      if self.pdop is None:
        self.pdop = 0.
      if self.vdop is None:
        self.vdop = 0.
      if self.gs is None:
        self.gs = 0.
      if self.tn is None:
        self.tn = 0
      if self.mn is None:
        self.mn = 0
      if self.sn is None:
        self.sn = []
      if self.elevation is None:
        self.elevation = []
      if self.azimuth is None:
        self.azimuth = []
      if self.snr is None:
        self.snr = []
      if self.sa1 is None:
        self.sa1 = [0,0,0,0]
      if self.sa2 is None:
        self.sa2 = [0,0,0,0]
      if self.sa3 is None:
        self.sa3 = [0,0,0,0]
      if self.sa4 is None:
        self.sa4 = [0,0,0,0]
      if self.sa5 is None:
        self.sa5 = [0,0,0,0]
      if self.sa6 is None:
        self.sa6 = [0,0,0,0]
      if self.sa7 is None:
        self.sa7 = [0,0,0,0]
      if self.sa8 is None:
        self.sa8 = [0,0,0,0]
    else:
      self.header = std_msgs.msg.Header()
      self.lat = 0.
      self.lon = 0.
      self.precision = 0
      self.satelites = 0
      self.hdop = 0.
      self.alt = 0.
      self.geo = 0.
      self.lack = 0
      self.rms = 0.
      self.smd1 = 0.
      self.smd2 = 0.
      self.smo = 0.
      self.laed = 0.
      self.loed = 0.
      self.aled = 0.
      self.id = []
      self.pdop = 0.
      self.vdop = 0.
      self.gs = 0.
      self.tn = 0
      self.mn = 0
      self.sn = []
      self.elevation = []
      self.azimuth = []
      self.snr = []
      self.sa1 = [0,0,0,0]
      self.sa2 = [0,0,0,0]
      self.sa3 = [0,0,0,0]
      self.sa4 = [0,0,0,0]
      self.sa5 = [0,0,0,0]
      self.sa6 = [0,0,0,0]
      self.sa7 = [0,0,0,0]
      self.sa8 = [0,0,0,0]

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_struct_3I.pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_2d2if2di7f.pack(_x.lat, _x.lon, _x.precision, _x.satelites, _x.hdop, _x.alt, _x.geo, _x.lack, _x.rms, _x.smd1, _x.smd2, _x.smo, _x.laed, _x.loed, _x.aled))
      length = len(self.id)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.id))
      _x = self
      buff.write(_struct_3f2i.pack(_x.pdop, _x.vdop, _x.gs, _x.tn, _x.mn))
      length = len(self.sn)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.sn))
      length = len(self.elevation)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.elevation))
      length = len(self.azimuth)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.azimuth))
      length = len(self.snr)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.snr))
      buff.write(_struct_4i.pack(*self.sa1))
      buff.write(_struct_4i.pack(*self.sa2))
      buff.write(_struct_4i.pack(*self.sa3))
      buff.write(_struct_4i.pack(*self.sa4))
      buff.write(_struct_4i.pack(*self.sa5))
      buff.write(_struct_4i.pack(*self.sa6))
      buff.write(_struct_4i.pack(*self.sa7))
      buff.write(_struct_4i.pack(*self.sa8))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(_x))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(_x))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _struct_3I.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 76
      (_x.lat, _x.lon, _x.precision, _x.satelites, _x.hdop, _x.alt, _x.geo, _x.lack, _x.rms, _x.smd1, _x.smd2, _x.smo, _x.laed, _x.loed, _x.aled,) = _struct_2d2if2di7f.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.id = struct.unpack(pattern, str[start:end])
      _x = self
      start = end
      end += 20
      (_x.pdop, _x.vdop, _x.gs, _x.tn, _x.mn,) = _struct_3f2i.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.sn = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.elevation = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.azimuth = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.snr = struct.unpack(pattern, str[start:end])
      start = end
      end += 16
      self.sa1 = _struct_4i.unpack(str[start:end])
      start = end
      end += 16
      self.sa2 = _struct_4i.unpack(str[start:end])
      start = end
      end += 16
      self.sa3 = _struct_4i.unpack(str[start:end])
      start = end
      end += 16
      self.sa4 = _struct_4i.unpack(str[start:end])
      start = end
      end += 16
      self.sa5 = _struct_4i.unpack(str[start:end])
      start = end
      end += 16
      self.sa6 = _struct_4i.unpack(str[start:end])
      start = end
      end += 16
      self.sa7 = _struct_4i.unpack(str[start:end])
      start = end
      end += 16
      self.sa8 = _struct_4i.unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_struct_3I.pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_2d2if2di7f.pack(_x.lat, _x.lon, _x.precision, _x.satelites, _x.hdop, _x.alt, _x.geo, _x.lack, _x.rms, _x.smd1, _x.smd2, _x.smo, _x.laed, _x.loed, _x.aled))
      length = len(self.id)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.id.tostring())
      _x = self
      buff.write(_struct_3f2i.pack(_x.pdop, _x.vdop, _x.gs, _x.tn, _x.mn))
      length = len(self.sn)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.sn.tostring())
      length = len(self.elevation)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.elevation.tostring())
      length = len(self.azimuth)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.azimuth.tostring())
      length = len(self.snr)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.snr.tostring())
      buff.write(self.sa1.tostring())
      buff.write(self.sa2.tostring())
      buff.write(self.sa3.tostring())
      buff.write(self.sa4.tostring())
      buff.write(self.sa5.tostring())
      buff.write(self.sa6.tostring())
      buff.write(self.sa7.tostring())
      buff.write(self.sa8.tostring())
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(_x))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(_x))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _struct_3I.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 76
      (_x.lat, _x.lon, _x.precision, _x.satelites, _x.hdop, _x.alt, _x.geo, _x.lack, _x.rms, _x.smd1, _x.smd2, _x.smo, _x.laed, _x.loed, _x.aled,) = _struct_2d2if2di7f.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.id = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      _x = self
      start = end
      end += 20
      (_x.pdop, _x.vdop, _x.gs, _x.tn, _x.mn,) = _struct_3f2i.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.sn = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.elevation = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.azimuth = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.snr = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 16
      self.sa1 = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=4)
      start = end
      end += 16
      self.sa2 = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=4)
      start = end
      end += 16
      self.sa3 = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=4)
      start = end
      end += 16
      self.sa4 = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=4)
      start = end
      end += 16
      self.sa5 = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=4)
      start = end
      end += 16
      self.sa6 = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=4)
      start = end
      end += 16
      self.sa7 = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=4)
      start = end
      end += 16
      self.sa8 = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=4)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
_struct_3f2i = struct.Struct("<3f2i")
_struct_3I = struct.Struct("<3I")
_struct_2d2if2di7f = struct.Struct("<2d2if2di7f")
_struct_4i = struct.Struct("<4i")
